#!/usr/bin/env perl

my $VERSION = '0.03';

use strict;
use warnings FATAL => 'all';

use Data::Dumper; # debug purposes only
use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config bundling);
use JSON qw(from_json to_json);
use Log::Log4Cli;
use NDTools::Struct qw(st_copy st_merge);
use Pod::Usage;
use Storable qw(dclone);
use Struct::Diff qw(diff dsplit);
use Struct::Path qw(spath);
use Struct::Path::PerlStyle qw(ps_parse);

# defaults
my $OPTS = {
    'json' => {
        allow_nonref => 1,
        canonical => 1,
        pretty => 1,
        relaxed => 1,
    },
    'style' => 'R_OVERRIDE',
    'verbose' => 0,
};

sub load_rules($) {
    return @{ from_json(read_file(shift), {relaxed => 1}) };
}

my @rules;

GetOptions (
    'dump-blame:s' => \$OPTS->{'dump-blame'},
    'dump-rules:s' => \$OPTS->{'dump-rules'},
    'file|f=s' => sub { push @rules, { src => $_[1] }},
    'help|h' => sub {
        pod2usage(-exitval => 1, -output => \*STDERR,
        -sections => 'SYNOPSIS|OPTIONS|EXAMPLES', -verbose => 99)
    },
    'ignore=s' => sub { push @{$rules[-1]->{'ignore'}}, $_[1] },
    'load-rules|rules=s' => sub { push @rules, load_rules($_[1]) },
    'merge=s' => sub { push @{$rules[-1]->{'merge'}}, { path => $_[1] } },
    'style=s' => sub {
        if (@rules) {
            if (exists $rules[-1]->{'merge'} and @{$rules[-1]->{'merge'}}) {
                $rules[-1]->{'merge'}->[-1]->{'style'} = $_[1]; # merge wide
            } else {
                $rules[-1]->{'style'} = $_[1]; # src wide
            }
        } else {
            $OPTS->{'style'} = $_[1]; # process wide
        }
    },
    'verbose|v:+' => \$OPTS->{'verbose'},
    'version' => sub { print "$VERSION"; exit 0; },
) || pod2usage(-exitval => 1, -output  => \*STDERR);

$Log::Log4Cli::L = $OPTS->{'verbose'};

my @blame;
my $result;

while (my $f = shift @ARGV) { push @rules, { src => $f }}; # files may also be defined via args

if (defined $OPTS->{'dump-rules'}) {
    print to_json(\@rules, $OPTS->{'json'});
    die_info "All done", 0;
}

for (my $r = 0; $r < @rules; $r++) {
    die_fatal "Undefined source in $r rule" unless (defined $rules[$r]{src});
    my $file = $rules[$r]{src};
    log_debug { "Loading file '$file'" };
    my $loaded = from_json(read_file($file), {relaxed => 1});

    if (exists $rules[$r]{ignore}) {
        for my $path (@{$rules[$r]{ignore}}) {
            log_debug { "Ignore '$rules[$r]{src}::$path'" };
            spath($loaded, ps_parse($path), delete => 1);
        }
    }

    my $style = exists $rules[$r]{style} ? $rules[$r]{style} : $OPTS->{'style'};
    my $merged;

    if (exists $rules[$r]{merge}) {
        $merged = dclone($result) if (defined $result);
        for my $m (@{$rules[$r]{merge}}) {
            my $subst = st_copy($loaded, ps_parse($m->{path}));
            my $rstyle = exists $m->{style} ? $m->{style} : $style; # per merge redefinable
            log_debug { "Merge ($rstyle) '$rules[$r]{src}::$m->{path}'" };
            $merged = st_merge($merged, $subst, style => $rstyle);
        }
    } else {
        log_debug { "Merge ($style) '$rules[$r]{src}'" };
        $merged = st_merge($result, $loaded, style => $style);
    }

    if ($OPTS->{'dump-blame'}) {
        push @blame, dsplit(diff($result, $merged, noO => 1, noU => 1));
        $blame[-1]{src} = $file;
    }

    $result = $merged;
}

write_file($OPTS->{'dump-blame'}, to_json(\@blame, $OPTS->{'json'})) if ($OPTS->{'dump-blame'});

print to_json($result, $OPTS->{'json'});

die_info "All done", 0;

__END__

=head1 NAME

ndmerge - Merge nested data structures according provided rules

=head1 SYNOPSIS

    ndmerge [OPTIONS]
    ndmerge [OPTIONS] <arguments>

=head1 DESCRIPTION

Easy way to get prototype inheritance for arbitrary JSON files (or others converted to it).

=head1 OPTIONS

=over 4

=item B<--dump-blame> [<file>]

Dump blame.

=item B<--dump-rules> [<file>]

Dump rules.

=item B<--file|-f> <file>

File to merge, also is a rule delimiter (all other opts affect only cpecified file). May
be used several times.

=item B<--help>

Print a help message and exit.

=item B<--ignore> <path>

Skip specified structure parts. May be used several times.

=item B<--merge> <path>

Don't merge whole document, only specified parts.
Paths '' or '{}' or '[]' means "whole" struct, use it as first merge target if whole struct must be merged
and some parts merged with specific options. May be used several times.

=item B<--style> <L_OVERRIDE|R_OVERRIDE>

Merge style.

=over 8

=item B<L_OVERRIDE>, B<R_OVERRIDE>

Objects merged, lists overrided, left and right precedence.

=back

Default is B<R_OVERRIDE>

=item B<--verbose>

Increase verbosity, max level - 4.

=item B<--version>

Prints version and exits.

=back

=head1 EXAMPLES

Simply merge three files:

    ndmerge a.json b.json c.json

Merge using rules, defined via opts:

    ndmerge \
        --file a.json \                      # define a sorce file to merge with
            --ignore '{some}[0,3]{path}' \   # matched subsrtuctures will not be merged from a.json
        --file b.json \                      # new file name is also set a 'namespace' for other opts
            --merge '{in_list}[2]' \         # merge only specified parts
            --style 'L_OVERRIDE'             # with non default style
        --file c.json                        # here merge style again will be default (ie R_OVERRIDE)

Merge using rules deined as file:

    ndmerge --rules rules.json               # rules may be saved to file adding --dump-rules for prev example
