#!/usr/bin/env perl

my $VERSION = '0.06';

use strict;
use warnings FATAL => 'all';

use NDTools::INC;

use Getopt::Long qw(:config bundling);
use Log::Log4Cli;
use Pod::Usage;
use Struct::Diff qw(diff dsplit);
use Struct::Path qw(spath);
use Struct::Path::PerlStyle qw(ps_parse);

use NDTools::Slurp qw(s_dump s_load);
use NDTools::Struct qw(st_copy st_merge);

# defaults
my $OPTS = {
    'style' => 'R_OVERRIDE',
};

my @rules;

GetOptions (
    'dump-blame=s' => \$OPTS->{'dump-blame'},
    'dump-rules=s' => \$OPTS->{'dump-rules'},
    'dump-prereqs=s' => \$OPTS->{'dump-prereqs'},
    'embed-rules=s' => \$OPTS->{'embed-rules'},
    'file|f=s' => sub { push @rules, { src => $_[1] }},
    'help|h' => sub {
        pod2usage(-exitval => 1, -output => \*STDERR,
        -sections => 'SYNOPSIS|OPTIONS|EXAMPLES', -verbose => 99)
    },
    'ignore=s' => sub { push @{$rules[-1]->{'ignore'}}, $_[1] },
    'load-rules|rules=s' => sub { push @rules, @{s_load($_[1], undef)} },
    'merge=s' => sub { push @{$rules[-1]->{'merge'}}, { path => $_[1] } },
    'style=s' => sub {
        if (@rules) {
            if (exists $rules[-1]->{'merge'} and @{$rules[-1]->{'merge'}}) {
                $rules[-1]->{'merge'}->[-1]->{'style'} = $_[1]; # merge wide
            } else {
                $rules[-1]->{'style'} = $_[1]; # src wide
            }
        } else {
            $OPTS->{'style'} = $_[1]; # process wide
        }
    },
    'verbose|v:+' => \$Log::Log4Cli::LEVEL,
    'version|V' => sub { print "$VERSION\n"; exit 0; },
) || pod2usage(-exitval => 1, -output  => \*STDERR);

my (@blame, $result);

while (my $f = shift @ARGV) { push @rules, { src => $f }}; # files may also be defined via args

die_fatal "At least one rule must be specified, see --help for details", 1 unless (@rules);

if (defined $OPTS->{'dump-rules'}) {
    s_dump($OPTS->{'dump-rules'}, undef, undef, \@rules);
    die_info "All done", 0;
} elsif (defined $OPTS->{'dump-prereqs'}) {
    s_dump($OPTS->{'dump-prereqs'}, undef, undef, [ map { $_->{src} } @rules ]);
    die_info "All done", 0;
}

for (my $r = 0; $r < @rules; $r++) {
    die_fatal "Undefined source in $r rule" unless (defined $rules[$r]{src});
    my $file = $rules[$r]{src};
    log_debug { "Loading file '$file'" };
    my $loaded = s_load($file, undef);

    if (exists $rules[$r]{ignore}) {
        for my $path (@{$rules[$r]{ignore}}) {
            log_debug { "Ignore '$rules[$r]{src}::$path'" };
            spath($loaded, ps_parse($path), delete => 1);
        }
    }

    my $style = exists $rules[$r]{style} ? $rules[$r]{style} : $OPTS->{'style'};
    my $merged = $result;

    if (exists $rules[$r]{merge}) {
        for my $m (@{$rules[$r]{merge}}) {
            my $subst = st_copy($loaded, ps_parse($m->{path}));
            my $rstyle = exists $m->{style} ? $m->{style} : $style; # per merge redefinable
            log_debug { "Merge ($rstyle) '$rules[$r]{src}::$m->{path}'" };
            $merged = st_merge($merged, $subst, style => $rstyle);
        }
    } else {
        log_debug { "Merge ($style) '$rules[$r]{src}'" };
        $merged = st_merge($result, $loaded, style => $style);
    }

    if ($OPTS->{'dump-blame'}) {
        push @blame, dsplit(diff($result, $merged, noO => 1, noU => 1));
        $blame[-1]{src} = $file;
    }

    $result = $merged;
}

if ($OPTS->{'embed-rules'}) {
    my $path = (spath($result, ps_parse($OPTS->{'embed-rules'}), expand => 1))[0];
    ${$path} = \@rules;
}

s_dump($OPTS->{'dump-blame'}, undef, undef, \@blame) if ($OPTS->{'dump-blame'});
s_dump(\*STDOUT, undef, undef, $result);

die_info "All done", 0;

__END__

=head1 NAME

ndmerge - Merge nested data structures according provided rules

=head1 SYNOPSIS

    ndmerge [OPTIONS]
    ndmerge [OPTIONS] <arguments>

=head1 DESCRIPTION

Easy way to get prototypal inheritance for arbitrary nested structures.

=head1 OPTIONS

=over 4

=item B<--dump-blame> E<lt>fileE<gt>

Dump blame.

=item B<--dump-rules> E<lt>fileE<gt>

Dump merge rules.

=item B<--dump-prereqs> E<lt>fileE<gt>

Dump list of prerequisites from merge rules.

=item B<--embed-rules> E<lt>pathE<gt>

Embed rules into structure.

=item B<--file|-f> E<lt>fileE<gt>

File to merge, also is a rule delimiter (all other opts affect only cpecified file). May
be used several times.

=item B<--help|-h>

Print a help message and exit.

=item B<--ignore> E<lt>pathE<gt>

Skip specified structure parts. Positional: per-source. May be used several times.

=item B<--load-rules|--rules> E<lt>fileE<gt>

Load merge rules from specified file. May be used several times.

=item B<--merge> E<lt>pathE<gt>

Don't merge whole document, only specified parts.
Paths '' or '{}' or '[]' means "whole" struct, use it as first merge target if whole struct must be merged
and some parts merged with specific options. Positional: per-source. May be used several times.

=item B<--style> E<lt>L_OVERRIDE|R_OVERRIDEE<gt>

Merge style. Positional: defines merge style per-process, per-source or per-merge according it's porition
relatively to B<--file> and B<--merge> options.

=over 8

=item B<L_OVERRIDE>, B<R_OVERRIDE>

Objects merged, lists overrided, left and right precedence.

=back

Default is B<R_OVERRIDE>

=item B<--verbose|-v> [int]

Increase verbosity, max level - 4.

=item B<--version|-V>

Print version and exit.

=back

=head1 EXAMPLES

Simply merge three files:

    ndmerge a.json b.json c.json

Merge using rules, defined via opts:

    ndmerge \
        --file a.json \                      # define a file to merge with
            --ignore '{some}[0,3]{path}' \   # matched subsrtuctures in a.json will not be merged
        --file b.json \                      # new file name is also set a 'namespace' for other opts
            --merge '{in_list}[2]' \         # merge only specified parts
            --style 'L_OVERRIDE'             # with non default style
        --file c.json                        # here merge style again will be default (ie R_OVERRIDE)

Merge using rules deined in file:

    ndmerge --rules rules.json               # rules may be saved to file by --dump-rules option
