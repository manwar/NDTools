#!/usr/bin/env perl

my $VERSION = '0.17';

use strict;
use warnings FATAL => 'all';

use NDTools::INC;

use Digest::MD5 qw(md5_hex);
use Encode::Locale qw(decode_argv);
use Getopt::Long qw(:config bundling);
use JSON qw(to_json);
use Log::Log4Cli;
use Pod::Usage;
use Struct::Path 0.65 qw(slist spath spath_delta);
use Struct::Path::PerlStyle qw(ps_parse ps_serialize);
use Term::ANSIColor qw(colored);
use NDTools::Slurp qw(s_dump s_load);

# defaults
my $OPTS = {
    'color-common' => 'bold black',
    'path' => '', # empty means whole doc
    'strict' => 1, # exit with 8 if unexisted path used
};

decode_argv(Encode::FB_CROAK);
GetOptions (
    'colors!' => \$OPTS->{colors},
    'depth|d=i' => \$OPTS->{depth},
    'help|h' => sub {
        pod2usage(-exitval => 0, -output => \*STDERR,
        -sections => 'SYNOPSIS|OPTIONS|EXAMPLES', -verbose => 99)
    },
    'list|l' => \$OPTS->{list},
    'md5' => \$OPTS->{md5},
    'path|p=s' => \$OPTS->{path},
    'out-fmt=s' => \$OPTS->{'out-fmt'},
    'raw-output' => \$OPTS->{'raw-output'},
    'strict!' => \$OPTS->{strict},
    'values|vals' => \$OPTS->{values},
    'verbose|v:+' => \$Log::Log4Cli::LEVEL,
    'version|V' => sub { print "$VERSION\n"; exit 0; },
) || pod2usage(-exitval => 1, -output  => \*STDERR);

$OPTS->{colors} = -t STDOUT ? 1 : 0 unless (defined $OPTS->{colors});

for my $file (@ARGV ? @ARGV : \*STDIN) {
    log_debug { "Processing " . (ref $file ? "STDIN" : "file '$file'") };
    my $data = s_load($file, undef);
    my $spath = eval { ps_parse($OPTS->{path}) };
    die_fatal "Failed to parse '$OPTS->{path}'", 4 if ($@);
    my @out = spath($data, $spath, deref => 1);
    unless (@out) {
        die_fatal "Failed to lookup '$OPTS->{path}' in structure", 8 if ($OPTS->{strict});
        next;
    }

    if ($OPTS->{list}) {
        for my $data (@out) {
            my $prev;
            for my $i (slist($data, depth => $OPTS->{depth})) {
                my @delta = spath_delta($prev, $i->[0]);
                my $cmn = @{$i->[0]} - @delta;
                $cmn = ($cmn and @{$i->[0]} != @delta) ? [ @{$i->[0]}[0 .. $cmn - 1] ] : [];
                $cmn = ps_serialize($cmn);
                $cmn = $OPTS->{colors} ? colored($cmn, $OPTS->{'color-common'}) : $cmn;
                my $val = "";
                if ($OPTS->{values}) {
                    $val = " = ";
                    if ($OPTS->{'raw-output'} and not ref ${$i->[1]}) {
                        $val .= ${$i->[1]};
                    } else {
                        $val .= to_json(${$i->[1]}, {canonical => 1, allow_nonref => 1});
                    }
                }
                print $cmn . ps_serialize(\@delta) . $val . "\n";
                $prev = $i->[0];
            }
        }
    } elsif ($OPTS->{md5}) {
        for my $data (@out) {
            print md5_hex(to_json($data, {canonical => 1, allow_nonref => 1})). " ($file)\n";
        }
    } else {
        for my $data (@out) {
            if ($OPTS->{'raw-output'} and not ref $data) {
                print $data . "\n";
            } else {
                s_dump(\*STDOUT, $OPTS->{'out-fmt'}, undef, $data);
            }
        }
    }
}

die_info "All done", 0;

__END__

=head1 NAME

ndquery - get desired parts from nested data structure

=head1 SYNOPSIS

    ndquery [OPTIONS]
    ndquery [OPTIONS] <arguments>

=head1 DESCRIPTION

Get specified by path parts from nested data structure

=head1 OPTIONS

=over 4

=item B<--[no]colors>

On/Off colors in --list mode.

=item B<--depth|-d> E<lt>intE<gt>

Combined with B<--list> allows to define how much levels must be listed.

=item B<--help|-h>

Print a help message and exit.

=item B<--list|-l>

List structure's paths.

=item B<--md5>

Calculate MD5 sum for structure.

=item B<--path|-p> E<lt>stringE<gt>

Path in the structure to deal with.

=item B<--raw-output>

Dont't format result simple things (strings/numbers) - dump them as is.

=item B<--[no]strict>

Fail if unexisted path specified. Enabled by default.

=item B<--values|--vals>

Values will be printed if combined with --list opt.

=item B<--verbose|-v> [int]

Increase verbosity, max level - 4.

=item B<--version|-V>

Print version and exit.

=back

=head1 EXAMPLES

Show as pretty printed canonical JSON:

    ndquery struct.json

Get specified path from document:

    ndquery --path '{some}{path}[2]' struct.json

List subpaths:

    ndquery --list --path '{some}{path}[2]' struct.json

Checksum for substructures:

    ndquery --md5 --path '{some}{path}' struct.json another.json

=head1 EXIT STATUS

 0   No errors occured.
 1   Generic error code.
 2   I/O Error.
 4   Path related errors.
 8   Path does not exists.

=head1 BUGS

Report bugs to L<https://github.com/mr-mixas/NDTools/issues>

=head1 SEE ALSO

L<jq(1)>

L<nddiff(1)>, L<ndpatch(1)>, L<ndproc(1)>

=head1 LICENSE AND COPYRIGHT

Copyright 2016,2017 Michael Samoglyadov C<< <mixas at cpan.org> >>.

This program is free software; you can redistribute it and/or modify it
under the terms of GNU General Public License 3 or later versions.
